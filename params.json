{"name":"Relate","tagline":"Relate is a tiny client-side relational document store.","body":"# Relate\r\n\r\n[![Bower version](https://badge.fury.io/bo/relate.svg)](http://badge.fury.io/bo/relate)\r\n\r\n**Relate** is a tiny client-side relational document store. It's useful for web applications with static data for which there are still relationships — for example, a record label might have a website in which there are artists, albums and songs, all of which relate to each other.\r\n\r\n## Dependencies\r\n\r\nNone! :tada:\r\n\r\n## Installation\r\n\r\nInstall manually: just copy `src/relate.js` wherever you'd like.\r\n\r\nInstall using Bower:\r\n\r\n```\r\nbower install --save relate\r\n```\r\n\r\nLoad in a browser:\r\n\r\n```html\r\n<script src=\"relate.js\"></script>\r\n```\r\n\r\nLoad using AMD:\r\n\r\n```javascript\r\nrequire(['Relate'], function (Relate) {\r\n  // ...\r\n});\r\n```\r\n\r\n## Documentation\r\n\r\n### Relate\r\n\r\n#### .import(data)\r\n\r\nTakes an object and populates the Relate datastore. The root object's properties are used as the collection names; its values are arrays of objects used as collection items. Each item must have an attribute `id` unique within its collection.\r\n\r\n```javascript\r\nRelate.import({\r\n  artists: [\r\n    {\r\n      id: 1,\r\n      name: 'Turnover',\r\n      songs: [1, 2]\r\n    }\r\n  ],\r\n  songs: [\r\n    {\r\n      id: 1,\r\n      name: 'Most Of The Time',\r\n      artist: 1\r\n    },\r\n    {\r\n      id: 2,\r\n      name: 'New Scream',\r\n      artist: 1\r\n    }\r\n  ]\r\n});\r\n```\r\n\r\n#### .collection(name)\r\n\r\nReturns the collection named `name`, or throws an error if it doesn't exist.\r\n\r\n```javascript\r\nRelate.collection('artists');\r\n// Relate.Collection {name: \"artists\", store: Object, add: function…}\r\n```\r\n\r\n#### .collection.create(name[, options])\r\n\r\nCreates a collection named `name` and returns it, or throws an error if a collection with that name already exists.\r\n\r\n- **transform**: a transformation function executed on each item added to the collection\r\n- **map**: an object mapping properties on the collection's items to other collections\r\n\r\n:speech_balloon: Shouldn't need to be called manually, since `Relate.import` will create collections automatically.\r\n\r\n```javascript\r\nvar Song = function () { /* ... */ };\r\n\r\nRelate.collection.create('songs', {\r\n  map: { artist: 'artists' },\r\n  transform: function (item) { return new Artist(item); }\r\n});\r\n// Relate.Collection {name: \"songs\", store: Object, add: function…}\r\n```\r\n\r\n#### .collection.exists(name)\r\n\r\nReturns true if a collection named `name` exists, or false if it doesn't.\r\n\r\n```javascript\r\nRelate.collection.exists('artists');\r\n// true\r\nRelate.collection.exists('labels');\r\n// false\r\n```\r\n\r\n#### .map\r\n\r\nAn object containing mappings between item properties and collection names. The keys in `Relate.map` correspond  to collection names. Each property in the collection's map object corresponds to a property on that collection's items, and each value corresponds to the name of the target collection.\r\n\r\n```javascript\r\nRelate.map.songs = { artist: 'artists' };\r\n```\r\n\r\n#### .mixin(item, collection)\r\n\r\nCopies the methods defined in `Item` to `item`, binding `item` and `collection` to each method as `this` and the first argument, respectively. If `Item.prefix` is defined, creates an object with that property on `item` and copies the method there, instead of directly on `item` itself.\r\n\r\n:speech_balloon: Shouldn't need to be called manually, since `Collection.add` will mix in `Item` methods automatically.\r\n\r\n#### .noConflict()\r\n\r\nIf it was set on a global object, restores `Relate` to its prior value and returns it.\r\n\r\n#### .transform\r\n\r\nAn object containing transformation functions executed on each item as it's imported into a collection. The properties in `Relate.transform` correspond to collection names. The transformation function receives the item's raw properties and the collection to which it will be added, and must return an object to be used as the item.\r\n\r\nTransforms must be set before data is imported.\r\n\r\n```javascript\r\nvar Artist = function () { /* ... */ };\r\n\r\nRelate.transform.artists = function (item, collection) { return new Artist(item); };\r\n```\r\n\r\n#### .defaultTransform\r\n\r\nA transformation function executed for every collection, unless that collection has a specific transformation function set in `Relate.transform`.\r\n\r\n### Collection\r\n\r\n#### Collection(name[, options])\r\n\r\nCreates a collection named `name` and returns it, or throws an error if a collection with that name already exists.\r\n\r\n- **transform**: a transformation function executed on each item added to the collection\r\n- **map**: an object mapping properties on the collection's items to other collections\r\n\r\n:bangbang: If a collection is created directly using the constructor, other collections and items will not be able to access it. Use `Relate.collection.create` instead.\r\n\r\n#### .add(item)\r\n\r\nGiven an object `item`, executes the collection's transformation function on it, mixes in the `Item` methods, adds it to the collection and returns it. If an item with the same ID already exists in the collection, throws an error.\r\n\r\n:speech_balloon: Shouldn't need to be called manually, since `Collection.import` will iterate over the array of items and add them.\r\n\r\n```javascript\r\nRelate.collection('artists').add({\r\n  id: 1,\r\n  name: 'Turnover',\r\n  songs: [1, 2]\r\n});\r\n```\r\n\r\n#### .get(query)\r\n\r\nIf `query` is an ID, returns the corresponding item in the collection. If `query` is an array of IDs, returns an array of the corresponding items in the collection. If `query` is a hash, returns an array of all items in the collection with matching keys and values.\r\n\r\n```javascript\r\nRelate.collection('songs').get(1);\r\n// Song {id: 1, name: \"Most Of The Time\", artist: 1, relate: Object}\r\nRelate.collection('songs').get([1, 2]);\r\n// [Song {id: 1, name: \"Most Of The Time\"…}, Song {id: 2, name: \"New Scream\"…}]\r\nRelate.collection('songs').get({ name: 'New Scream' });\r\n// [Song {id: 2, name: \"New Scream\"…}]\r\n```\r\n\r\n#### .import(items)\r\n\r\nTakes an array and populates the collection. Each object in the array is used as an item and must have a unique attribute `id`.\r\n\r\n:speech_balloon: Shouldn't need to be called manually, since `Relate.import` will import each array of items into a collection automatically.\r\n\r\n```javascript\r\nRelate.collection('songs').import([\r\n  {\r\n    id: 1,\r\n    name: 'Most Of The Time',\r\n    artist: 1\r\n  },\r\n  {\r\n    id: 2,\r\n    name: 'New Scream',\r\n    artist: 1\r\n  }\r\n]);\r\n```\r\n\r\n#### .key(key)\r\n\r\nReturns the collection name mapped to property `key`, if it exists, or returns `key` if it corresponds to an unmapped collection. Otherwise, returns `undefined`.\r\n\r\n```javascript\r\nRelate.map.songs = { artist: 'artists' };\r\n\r\nRelate.collection('songs').key('artist');\r\n// \"artists\"\r\nRelate.collection('songs').key('songs');\r\n// \"songs\"\r\nRelate.collection('songs').key('name');\r\n// undefined\r\n```\r\n\r\n#### .mapped(key)\r\n\r\nReturns true if a mapping exists in the collection for property `key`, or false if it does not.\r\n\r\n```javascript\r\nRelate.map.songs = { artist: 'artists' };\r\n\r\nRelate.collection('songs').key('artist');\r\n// true\r\nRelate.collection('songs').key('songs');\r\n// false\r\n```\r\n\r\n### Item\r\n\r\n#### .get(key)\r\n\r\nGiven a property `key` that exists on an item, returns either the related item in the corresponding collection or property's value.\r\n\r\n```javascript\r\nRelate.collection('songs').get(1).get('name');\r\n// \"Most Of The Time\"\r\nRelate.collection('songs').get(1).get('artist');\r\n// Artist {id: 1, name: \"Turnover\", songs: Array[2], relate: Object}\r\n```\r\n\r\n#### .prefix\r\n\r\nA string used as a namespace for `Item` methods copied to items. Used to prevent conflicts between `Item` methods and properties that already exist in items.\r\n\r\n```javascript\r\nRelate.Item.prefix = 'relate';\r\n\r\nRelate.collection('songs').get(1).relate.get('artist');\r\n// Artist {id: 1, name: \"Turnover\", songs: Array[2], relate: Object}\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}